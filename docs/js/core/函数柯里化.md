---
slug: currying
tags: [js-core]
---

## [函数柯里化](https://zh.javascript.info/currying-partials)
:::tip
- 柯里化是一种函数的转换，柯里化不会调用函数。它只是对函数进行转换。
:::

### 1. 简单的例子：
```js
// 执行柯里化转换
function curry(f) {
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// 用法
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
```

- `curry(func)` 的结果就是一个包装器 `function(a)`
- 当它被像 `curriedSum(1)` 这样调用时，**它的参数会被保存在词法环境中**，然后返回一个新的包装器 `function(b)`
- 然后这个包装器被以 2 为参数调用，并且，它将该调用传递给原始的 sum 函数

### 2. 柯里化更高级的实现
例如 lodash 库的 `_.curry`，会返回一个包装器，该包装器允许函数被正常调用或者以部分应用函数（partial）的方式调用：
```js
function sum(a, b) {
  return a + b;
}

let curriedSum = _.curry(sum); // 使用来自 lodash 库的 _.curry

alert( curriedSum(1, 2) ); // 3，仍可正常调用
alert( curriedSum(1)(2) ); // 3，以部分应用函数的方式调用
```

### 3. 柯里化的好处
柯里化让我们能够更容易地获取 部分应用函数(partially applied function)（或者说 部分函数(partial)）。
```js
// 例如一个普通的日志函数
function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}
// 将它柯里化
log = _.curry(log);

log(new Date(), "DEBUG", "some debug"); // (a, b, c)形式使用
log(new Date())("DEBUG")("some debug"); // (a)(b)(c)形式使用

// 为当前日志创建便捷函数
let logNow = log(new Date()); // logNow 会是带有固定第一个参数的日志的部分应用函数
logNow("INFO", "message"); // [HH:mm] INFO message

let debugNow = logNow("DEBUG");
debugNow("message"); // [HH:mm] DEBUG message
```

### 4. 手写实现柯里化
- 如果传入的 args 长度与原始函数所定义的（func.length）相同或者更长，那么只需要使用 func.apply 将调用传递给它即可。
- 否则，获取一个部分应用函数，它将重新应用 curried，将之前传入的参数与新的参数一起传入。
- 然后，如果我们再次调用它，我们将得到一个新的部分应用函数（如果没有足够的参数），或者最终的结果。
- 这种方式实现的柯里化，要求函数具有固定数量的参数；使用 rest 参数的函数，例如 f(...args)，不能以这种方式进行柯里化。

```js
function curry(func) {

  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  };

}

// 用例
function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

alert( curriedSum(1, 2, 3) ); // 6，仍然可以被正常调用
alert( curriedSum(1)(2,3) ); // 6，对第一个参数的柯里化
alert( curriedSum(1)(2)(3) ); // 6，全柯里化
```

### 5. 柯里化在实际项目中的应用
请求是多样化的，比如method的不同；有的需要data，有的没有入参不需要data；有的需要配置请求头等参数，有的不需要配置：
```js
// get
fn('a/b', {header:{}})
fn('a/b')

// post
fn('a/b', {a:1}, {header:{}})
fn('a/b', {a:1})
fn('a/b', {header:{}})
```

我封装了2个版本（还有更好更优雅的封装方式）：
- 1) 调用时得写两个括号
```ts
// fn('a/b')({header:{}})
// fn('a/b', {a:1})({header:{}})
// fn('a/b')()
// fn('a/b', {a:1})()
function requestApi(...rest: any[]) {
  const {tokenReducer} = store.getState();
  
  let params;
  if (rest.length > 1) {
    params = {
      method: rest[0] ?? 'POST',
      url: rest[1],
      data: rest[2],
    };
  } else {
    params = { url: rest[0], method: 'POST', };
  }
  return async function withConfig(config?: any) {
    const result = await Taro.request({
      ...params,
      header: {
        'Authorization': `Bearer ${tokenReducer.token || my.getStorageSync({ key: 'selfAppToken' })?.data}`
      }
    });
    return result.data;
  };
}

// 使用
export const getStudentInfoListApi = () => requestApi('POST', `${prefix}student/queryStudentInfoList`);

let childrenResult = await getStudentInfoListApi()();
```

- 2) 使用柯里化
```ts
function curry(func) {
  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  }
}
// fn('a/b', {a:1}, {header:{}})
// fn('a/b', {a:1})
// fn('a/b', {header:{}})
function commonRequest(method: keyof Taro.request.Method | undefined, url: string, {data, config}: {data: any, config: any} = {} as {data: any, config: any}) { // 使用对象解构可以不用考虑data config顺序不固定的问题
  const {tokenReducer} = store.getState();
  const prefix = 'https://xxx/';
  return new Promise((resolve, reject) => {
    Taro.request({
      method,
      url: `${prefix}${url}`,
      ...{
        data,
        config,
        header: {
          'Authorization': `Bearer ${tokenReducer.token || my.getStorageSync({ key: 'selfAppToken' })?.data}`
        }
      },
      success: function (successResult) {
        resolve(successResult.data);
      },
      fail: function (failResult) {
        reject(failResult);
      }
    });
  }).catch(error => {
    Taro.showToast({
      title: error,
      icon: 'error',
      duration: 1500,
    });
  })
}

const postApi = curry(commonRequest)('POST');
const getApi = curry(commonRequest)('GET');

// 使用
export const getParentInfoApi = () => postApi('getParentInfo');

let result = await getParentInfoApi();
```